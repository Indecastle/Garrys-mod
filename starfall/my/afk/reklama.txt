--@name Reklama troit5sky
--@author Markiz & OctopuSSX
--@client

local AFK = chip()
AFK = find.playersByName("mark")[1]
/*AFK = find.allPlayers(function(p)
    if p:getSteamID() == "STEAM_0:0:582893321" then
        return true
    end
end)[1]*/
print(AFK)

local Data = {
    {   text={"Garry's Mod Space"}, 
        //font = "Courier New",
        fontSize=60, 
        fontBold=1000, 
        bold=false,
        color=Color(0,255,0),

    },
    {   text={"не любишь PVP? Пропиши !build в чат",}, 
        fontSize=57, 
        fontBold=1000, 
        margin=60,
        bold=false,
        color=Color(255,180,50) 
    },
    {text={"----------------------------------------------"}, fontSize=40, fontBold=1000, marginUp=50},
    {   text={"правила: !motd",
                "сайт: http://gm.troit5sky.ru"}, 
        fontSize=40, 
        fontBold=1000, 
        marginUp=40,
    }
}

local Mode = 2 // 1, 2, 3, 4

local isRotate = false
local rotateSpeed = 100
local swaySpeed = 2
local swayDegreesMax = 0

local IsStaticVertical = false // only for Mode == 1 or 2
local IsDoubleData = true
local isHideTarget = true

local shadowIterations = 10
local shadowOffset = 1

local ColorSpeed = 50

local textSize = 200 // 300
local DataOffsetZ = 34

local isParentPos = true
local isParentAngle = true



// ##################### don't touch !!! #####################

function pos(mode)
    return AFK:getEyePos() + 
        ((Mode==1 or Mode==2) and Vector(0, 0, DataOffsetZ) or 
        Mode==3 and AFK:getForward()*DataOffsetZ or
        Mode==4 and AFK:getUp()*DataOffsetZ)
end
function table.map(t, func)
    local maped = {}
    for i=1, #t do
        maped[i] = func(t[i])
    end
    return maped
end
function table.sum(t, func)
    local sum_ = 0
    for i=1, #t do
        sum_ = sum_ + func(t[i])
    end
    return sum_
end
function table.all(t, func)
    for i=1, #t do
        if not func(t[i]) then
            return false
        end
    end
    return true
end
function table.reduce(list, fn, init)
    local acc = init
    for k, v in ipairs(list) do
        if 1 == k and not init then
            acc = v
        else
            acc = fn(acc, v)
        end
    end
    return acc
end


if isHideTarget and AFK == player() then return end

local _startX, _startY = 512 - shadowIterations*shadowOffset, 512 + shadowIterations*shadowOffset
local _endX, _endY = 512, 512
render.createRenderTarget("afkscreen0")
render.createRenderTarget("afkscreen")

local mat = material.create("UnlitGeneric")
mat:setInt("$flags", 2^21) // translucent  -->  2097152
mat:setTextureRenderTarget("$basetexture", "afkscreen")

local text = holograms.create(pos(), Angle(), "models/holograms/plane.mdl")
text:setMaterial("!" .. mat:getName())
text:setSize(Vector(textSize, textSize, 1))


local text2 = holograms.create(pos(), Angle(), "models/holograms/plane.mdl")
text2:setMaterial("!" .. mat:getName())
text2:setSize(Vector(textSize, textSize, 1))
if not IsDoubleData then
    text2:setColor(Color(0,0,0,0))
end

//local font = render.createFont("Roboto", fontSize, fontBold, true)
for i=1, #Data do
    Data[i].font = render.createFont(Data[i].font, Data[i].fontSize, Data[i].fontBold, true)
end

local isStatic = table.all(Data, function(x) return x.color ~= nil end)

table.foreachi(Data, function(i, V)
    if V.fontSize == nil then V.fontSize = 100 end
    if V.font == nil then V.font = "Roboto" end
    if V.fontBold == nil then V.fontBold = 1000 end
    //if V.margin == nil then V.margin = 50 end
    if V.marginUp == nil then V.marginUp = 0 end
    if V.marginDown == nil then V.marginDown = 0 end
    if V.align == nil then V.align = TEXT_ALIGN.CENTER end
    if V.bold == nil then V.bold = false end
    if V.color == nil and V.colorSpeed == nil then V.color = Color(255,255,255) end
    if V.colorSpeed == nil then V.colorSpeed = 0.5 end
end)


//Data[1].offset = 0


DataOffsetZ = DataOffsetZ + 
    (   (Mode==1 or Mode==2) and 10*textSize/100 or
        Mode==3 and 0 or
        Mode==4 and 0 or 
        0)
    

InitAngle = Mode==1 and Angle(90,0,0) or 
            Mode==2 and Angle(90,0,0) or
            Mode==3 and Angle(0,0,0) or
            Mode==4 and Angle(90,0,0) or
            Angle(0,0,0)

//local font = render.setFont("ChatFont")
//render.setFont(font)

// ##################### don't touch !!! #####################

local isCreated = false
local isFirstParentPos = true
local isFirstParentAngle = true

function getMargin(obj, isUp)
    return obj.margin != nil and obj.margin or (isUp and obj.marginUp or obj.marginDown)
end

function getPrevMargin(j, k)
    if (j==1 and k==1) then return getMargin(Data[j]) end
    if k == 1 then
        return getMargin(Data[j-1])
    end
    return getMargin(Data[j])
end

function getOffset(j, k)
    if (j==1 and k==1) then return 0 end
    local marginUp, marginDown = getMargin(Data[j], true), getPrevMargin(j, k)
    return math.max(marginUp, marginDown)
end


local averageOffset = 0
for j=1, #Data do
    for k=1, #Data[j].text do
        averageOffset = averageOffset + getOffset(j, k)
    end
end
averageOffset = (averageOffset) / 2




function renderBold()
    render.selectRenderTarget("afkscreen0")
    render.clear(Color(0, 0, 0, 0))
    for i = 1, shadowIterations do
        render.setColor(Color(0, 0, 0) / (shadowIterations-i))
        local offset = -averageOffset
        for j=1, #Data do
            render.setFont(Data[j].font)
            for k=1, #Data[j].text do
                offset = offset + getOffset(j, k)
                if Data[j].bold then
                    render.drawSimpleText(_startX + i*shadowOffset, offset + _startY - i*shadowOffset, Data[j].text[k], Data[j].align, TEXT_ALIGN.CENTER)
                end
            end
        end
    end
end


function renderText()

    render.selectRenderTarget("afkscreen")
    render.clear(Color(0, 0, 0, 0))
    
    render.setRenderTargetTexture("afkscreen0")
    render.drawTexturedRect(0, 0, 1024, 1024)
    
    local offset = -averageOffset
    
    for j=1, #Data do
        if Data[j].color == nil then
            render.setColor(Color(math.cos(timer.systime() * Data[j].colorSpeed) * 360, 1, 1):hsvToRGB())
        else
            render.setColor(Data[j].color)
        end
        
        render.setFont(Data[j].font)
        for k=1, #Data[j].text do
            offset = offset + getOffset(j, k)
            render.drawSimpleText(_endX, offset + _endY, Data[j].text[k], Data[j].align, TEXT_ALIGN.CENTER)
        end
    end
end


hook.add("renderoffscreen", "", function()
    if !isCreated then
        renderBold()
    end
    
    if !isStatic or !isCreated then
        renderText()
    end
    
    isCreated = true
end)




hook.add("think", "", function()
    local eyeAngle;
    if Mode == 1 then
        local d = (-player():getForward()):getNormalized()
        eyeAngle = d:getAngle()  + InitAngle
    elseif Mode == 2 then
        local d = (player():getEyePos() - pos()):getNormalized()
        eyeAngle = d:getAngle()  + InitAngle
    elseif Mode==3 or Mode==4 then
        eyeAngle = AFK:getAngles() + InitAngle
    end
    
    //print(d)
    
    if (Mode==1 or Mode==2) and IsStaticVertical then
        eyeAngle:setP(90)
    end
    
    if isRotate then
        eyeAngle = eyeAngle + Angle(0,  timer.systime()*rotateSpeed, 0)
    end
    
    if swayDegreesMax != 0 then
        local quat1 = eyeAngle:getQuaternion()
        local quat2 = (Vector(0,0,1)):getQuaternionFromAxis( math.cos(timer.systime()*swaySpeed)*swayDegreesMax )
        local quat4 = quat1 * quat2
        eyeAngle = quat4:getEulerAngle()
        
    end
    
    //text:setAngles(eyeAngle + Angle(90, 0, math.cos(timer.systime()*rotateSpeed)*70))
    //text:setAngles(eyeAngle + Angle(90, 90, 90))
    
    if isParentPos or isFirstParentPos then 
        isFirstParentPos = false
        text:setPos(pos()) 
        if IsDoubleData then text2:setPos(pos()) end 
    end
    if isParentAngle or isFirstParentAngle then 
        isFirstParentAngle = false
        text:setAngles(eyeAngle) 
        if IsDoubleData then text2:setAngles(eyeAngle + Angle(0,0,180)) end
    end
end)