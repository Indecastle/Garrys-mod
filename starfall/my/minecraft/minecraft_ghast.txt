--@name Minecraft Ghast
--@author Markiz
--@shared

local Respawn = true
local GhastSpawnCounts = 1 -- max 5

local Health = 200
local MaxTakeDamage = 100


local GhastVelocity = 3
local MoveRadius = 2000
local MoveHeightMin = 150
local MoveHeightMax = 400
local TriggerOnlyWord = false

local InterpolationMove = false
local InterpolationMoveRatio = 20

local TargetRadius = 1000
local BulletVelocity = 20
local PropDamageMode = true
local BulletLifeTime = 10
local BulletObbSize = 30

local LockDamageTime = 0
local DeathAngleVelocity = 3

local ExplodeModels = {
    "models/props_phx/misc/potato_launcher_explosive.mdl",
    "models/props_phx/ww2bomb.mdl",
    "models/props_junk/propane_tank001a.mdl",
    "models/props_phx/oildrum001_explosive.mdl",
    "models/props_c17/oildrum001_explosive.mdl",
}

----------------------------------------------------------

local E = chip()
local _ghastActiveList = {}
local _ghastBulletList = {}


function getFrameTime()
    return timer.frametime() * 30
end

function getNewId()
    return ''..math.random(10000)..'_'..math.random(10000)..'_'..math.random(10000)
end

if SERVER then
    
    local GhastClass = class("GhastClass")
    local BulletClass = class("BulletClass")
    
    function isValidPlayerOrNPC(ent)
        return ent ~= nil and ent:isValid()
            and (ent:isNPC() or not IgnorePlayers and ent:isPlayer() and ent:isValidPhys() and ent:isAlive() and !ent:hasGodMode())
    end
    
    function GhastClass:initialize(pos)
        self.ID = getNewId()
        _ghastActiveList[self.ID] = self
        
        self.model = "models/hunter/blocks/cube2x2x2.mdl"
        self._health = Health
        self._isAlive = true
        
        propBase = prop.create(pos, Angle(), self.model, true)
        propBase:setColor(Color(0,0,0,0))
        propBase:setMaterial("models/debug/debugwhite")
    
        self.propBase = propBase or nil
        self.isDisposed = false
        
        self.forward = propBase:getForward()
        self.head = hologram.create(propBase:getPos(), self.forward and self.forward:getAngle() or Angle(), "models/hunter/blocks/cube2x2x2.mdl", Vector(1.0, 1.0, 1,0))
        self.head:setMaterial("models/debug/debugwhite")
        self.head:setParent(propBase)
        self.head:setColor(Color(240,240,240))
        
        self:buildHolosFireState()
        self:buildHolosNotFireState()
        self:setFireState(false)
        
        self.legSpeed = 3
        self.legConfigList = { // field "Length" between 0 and 80
            {TimeDegreeOffset = 0, X = -38, Y =  35, Length = 60},
            {TimeDegreeOffset = 0, X =  25, Y =  35, Length = 40},
            
            {TimeDegreeOffset = 90, X =  0, Y =  20, Length = 40},
            
            {TimeDegreeOffset = 120, X = -38, Y =  5, Length = 40},
            {TimeDegreeOffset = 120, X =  25, Y =  5, Length = 60},
            
            {TimeDegreeOffset = 140, X =  0, Y =  -10, Length = 40},
            
            {TimeDegreeOffset = 170, X = -38, Y =  -25, Length = 60},
            {TimeDegreeOffset = 170, X =  25, Y =  -25, Length = 40},
            
            {TimeDegreeOffset = 200, X =  0, Y =  -40, Length = 40},
        }
        self:buildLegs()
        self:setScreamState(false)
        
        
        self._timerScreamingKey = self.ID .. "_timerScreamingKey"
        self._currentPos = self.propBase:getPos()
        self._killingHoloAngle = 0
        self._oldLockDamageTime = timer.systime()
        self._isStuck = false
        self._moveForward = Angle(5, math.rand(-180,180), 0):getForward()
        self._traceMask = TriggerOnlyWord and 24737 or MASK.ALL
        self._zForward = 0
        self._zDir = nil
        
        net.start("AddGhast")
        net.writeString(self.ID)
        net.writeEntity(self.propBase)
        net.send()
    end
    
    function GhastClass:buildHolosNotFireState()
        self.head_eye1 = hologram.create(self.head:localToWorld(Vector(47,-18,20)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,2.0,0.45))
        self.head_eye2 = hologram.create(self.head:localToWorld(Vector(47, 18,20)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,2.0,0.45))
        self.head_mouth = hologram.create(self.head:localToWorld(Vector(47,0,-25)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,2.0,0.45))
        
        self.head_eye1:setParent(self.head)
        self.head_eye2:setParent(self.head)
        self.head_mouth:setParent(self.head)
        
        self.head_eye1:setColor(Color(70,70,70))
        self.head_eye2:setColor(Color(70,70,70))
        self.head_mouth:setColor(Color(70,70,70))
        
        self.holoNoFireList = {self.head_eye1, self.head_eye2, self.head_mouth}
    end
    
    function GhastClass:buildHolosFireState()
        local head_eye11 = hologram.create(self.head:localToWorld(Vector(47,-18,20)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,2.0,0.45))
        local head_eye12 = hologram.create(self.head:localToWorld(Vector(47,-18,24)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,1.0,0.6))
        local head_eye13 = hologram.create(self.head:localToWorld(Vector(47.2,-15,20)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,0.5,0.45))
        
        local head_eye21 = hologram.create(self.head:localToWorld(Vector(47, 18,20)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,2.0,0.45))
        local head_eye22 = hologram.create(self.head:localToWorld(Vector(47,18,24)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,1.0,0.6))
        local head_eye23 = hologram.create(self.head:localToWorld(Vector(47.2,15,20)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,0.5,0.45))
        
        local head_mouth1 = hologram.create(self.head:localToWorld(Vector(47,0,-24)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,2.0,1.3))
        local head_mouth2 = hologram.create(self.head:localToWorld(Vector(47,0,-25)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,1.0,2.3))
        local head_mouth3 = hologram.create(self.head:localToWorld(Vector(47.2,0,-26)), self.head:getAngles(), "models/holograms/cube.mdl", Vector(0.11,1.0,1.0))
        
        head_eye11:setParent(self.head)
        head_eye12:setParent(self.head)
        head_eye13:setParent(self.head)
        head_eye21:setParent(self.head)
        head_eye22:setParent(self.head)
        head_eye23:setParent(self.head)
        head_mouth1:setParent(self.head)
        head_mouth2:setParent(self.head)
        head_mouth3:setParent(self.head)
        
        head_eye11:setColor(Color(70,70,70))
        head_eye12:setColor(Color(70,70,70))
        head_eye13:setColor(Color(255,70,70))
        head_eye21:setColor(Color(70,70,70))
        head_eye22:setColor(Color(70,70,70))
        head_eye23:setColor(Color(255,70,70))
        
        head_mouth1:setColor(Color(70,70,70))
        head_mouth2:setColor(Color(70,70,70))
        head_mouth3:setColor(Color(255,70,70))
        
        self.holoFireList = {head_eye11, head_eye12, head_eye13, head_eye21, head_eye22, head_eye23, head_mouth1, head_mouth2, head_mouth3}
    end
    
    function GhastClass:buildLegs()
        local x = (timer.systime()*2) % 360
        for i, data in ipairs(self.legConfigList) do
            local localPos = Vector(data.X, data.Y+2, -47)
            local length = math.clamp(data.Length-40, -40, 40)
            local legBone = hologram.create(self.head:localToWorld(localPos), self.forward and self.head:localToWorldAngles(Angle(120,0,0)), "models/hunter/plates/plate.mdl", Vector(1.0, 1.0, 1,0))
            local leg = hologram.create(legBone:localToWorld(Vector(length,6,0)), self.forward and legBone:localToWorldAngles(Angle(0,90,0)), "models/hunter/blocks/cube025x2x025.mdl", Vector(1.0, 1.0, 1,0))
            leg:setClip(i, true, Vector(0, 0, -46), Vector(0,0,-1), self.head)
            legBone:setParent(self.head)
            leg:setParent(legBone)
            leg:setColor(Color(240,240,240))
            leg:setMaterial("models/debug/debugwhite")
            legBone:setNoDraw(true)
            
            data.HoloBone = legBone
            data.HoloLeg = leg
        end
    end
    
    function GhastClass:setScreamState(isScreaming)
        if not self:isAlive() then return end
        local color = isScreaming and Color(250, 170, 170) or Color(240,240,240)
        self.head:setColor(color)
        for i, h in ipairs(self.legConfigList) do
            h.HoloLeg:setColor(color)
        end
    end

    function GhastClass:destruct()
        if self.isDisposed then throw("Ghast is already disposed") end
        _ghastActiveList[self.ID] = nil
        self.propBase:remove()
        self.isDisposed = true
        self._isAlive = false
        
        net.start("RemoveGhast")
        net.writeString(self.ID)
        net.send()
    end
    
    function GhastClass:isAlive()
        return self._isAlive and not self.isDisposed
    end
    
    function GhastClass:hide()
        if self.isDisposed then return end
        self.head_eye1:setColor(Color(0,0,0,0))
        self.head_eye2:setColor(Color(0,0,0,0))
        self.head_mouth:setColor(Color(0,0,0,0))
        self.head:setColor(Color(0,0,0,0))
    end
    
    function GhastClass:setFireState(isFire)
        if self.isDisposed then return end
        for i, h in ipairs(self.holoNoFireList) do
            h:setColor(h:getColor():setA(isFire and 0 or 255))
        end

        for i, h in ipairs(self.holoFireList) do
            h:setColor(h:getColor():setA(isFire and 255 or 0))
        end
    end
    
    function GhastClass:think()
        if not self:isAlive() then return end
        self:thinkLegs()
        
        self:headAngleHandler()
        self:calculateForwardAI()
        self:move()
    end
    
    function GhastClass:think05sec()
        if not self:isAlive() then return end
        self:findTarget()
        
    end
    
    function GhastClass:think3sec()
        if not self:isAlive() then return end
        self:attackTarget()
    end
    
    function GhastClass:thinkLegs()
        if not self:isAlive() then return end
        for i, data in ipairs(self.legConfigList) do
            local x = (timer.curtime()*self.legSpeed + math.rad(data.TimeDegreeOffset)) % math.pi*2
            data.HoloBone:setAngles(self.head:localToWorldAngles(Angle(110+math.sin(x)*15, 0, 0)))
        end
    end
    
    function GhastClass:findTarget()
        if not self:isAlive() then return end
        local myPos = self.head:getPos()
        local players = find.allPlayers(function(ent)
            return ent:getPos():getDistance(myPos) < TargetRadius and isValidPlayerOrNPC(ent)
        end)
        local npc = find.byClass("npc*", function(ent)
            return ent:getPos():getDistance(myPos) < TargetRadius and isValidPlayerOrNPC(ent)
        end)
        table.add(players, npc)
        self._target = find.closest(players, myPos)
    end
    
    function GhastClass:headAngleHandler()
        local dir
        if isValid(self._target) then 
            dir = self._target:getPos() - self.propBase:getPos()
        else
            dir = self._moveForward
        end
        
        local ang = dir:getAngle()
        ang.p = 0
        local result = math.lerpAngle(0.2, self.propBase:getAngles(), ang)
        self.propBase:getPhysicsObject():setAngles(result)
    end
    
    function GhastClass:attackTarget()
        if not isValid(self._target) then return end
        net.start("AttackTarget")
        net.writeString(self.ID)
        net.writeEntity(self._target)
        net.send()
        

        self:setFireState(true)
        timer.simple(0.8, function()
            if not isValid(self.propBase) or not isValid(self._target) then return end
            local bulletStartPos = self.propBase:localToWorld(Vector(47,0,-24))
            local bullet = BulletClass:new(bulletStartPos, self._target:obbCenterW(), self.propBase)
        end)
        timer.simple(1, function()
            self:setFireState(false)
        end)
    end
    
    function GhastClass:entityTakeDamage(amount)
        if not self._isAlive
            or self.isDisposed
            or timer.systime() < self._oldLockDamageTime 
            then return end
        
        self._oldLockDamageTime = timer.systime() + LockDamageTime
        
        amount = math.clamp(amount, 0, MaxTakeDamage)
        self._health = math.max(0, self._health - amount)
        
        self:setScreamState(true)
        
        if self._health <= 0 then
            self._isAlive = false
            self:killingScene()
            timer.remove(self._timerScreamingKey)
        else
            timer.create(self._timerScreamingKey, 0.5, 1, function()
                self:setScreamState(false)
            end)
        end
        
        net.start("EntityTakeDamage")
        net.writeString(self.ID)
        net.writeFloat(amount)
        net.writeFloat(self._health)
        net.send()
    end
    
    function GhastClass:killingScene()
        local hookId = ""..self.ID.."killingScene"
        hook.add("think", hookId, function()
            if not isValid(self.propBase) or not isValid(self.head) then return end
            
            self.head:setAngles(self.propBase:localToWorldAngles(Angle(0, 0, self._killingHoloAngle)))
            
            self._killingHoloAngle = self._killingHoloAngle + DeathAngleVelocity
            if self._killingHoloAngle > 90 then
                hook.remove("think", hookId)
                timer.simple(0.5, function()
                    self:destruct()
                end)
            end
        end)
    end

    function GhastClass:calculateForwardAI()
        local pos = InterpolationMove and self._currentPos or self.propBase:getPhysicsObject():getPos()
        local tr = trace.line(pos, pos + Vector(0, 0, -MoveHeightMax), {self.propBase}, self._traceMask, nil, false)
        local dist = tr.HitPos:getDistance(pos)
        --print(dist)
        local zDir, zForward
        
        if dist < MoveHeightMin then zDir = -1
        elseif dist >= MoveHeightMax then zDir = 1
        end

        if not self._zDir and zDir then
            zForward = zDir * 70
            self._zDir = zDir
        elseif self._zDir and not zDir then
            zForward = self._zDir * 5
            self._zDir = nil
        end

        if zForward then
            --printConsole('zForward - '..zForward)
            local ang = self._moveForward:getAngle()
            ang.p = zForward
            self._moveForward = ang:getForward()
            self._zForward = zForward
        end

        self._isStuck = false
        local step = math.max(GhastVelocity, 10)
        local tr2 = trace.line(pos, pos + self._moveForward * step, {self.propBase}, self._traceMask, nil, false)
        if tr2.Hit or not self:isInMoveValidRadius(tr2.HitPos) then
            self._isStuck = true
            for i=1, 3 do
                if i == 2 then self._zForward = -self._zForward end
                if i > 2 then self._zForward = math.rand(-90,90) end
                --printConsole(''..i..' - '..self._zForward)
                local newDir = Angle(self._zForward, math.rand(-180,180), 0):getForward()
                tr2 = trace.line(pos, pos + newDir * step, {self.propBase}, self._traceMask, nil, false) 
                if not tr2.Hit and self:isInMoveValidRadius(tr2.HitPos) then
                    self._moveForward = newDir
                    self._isStuck = false
                    break
                end
            end
        end
    end
    
    function GhastClass:isInMoveValidRadius(pos)
        local origin = chip():getPos()
        --local obbMins = origin - Vector(MoveRadius)
        --local obbMaxs = origin + Vector(MoveRadius)

        return math.abs(origin.x - pos.x) <= MoveRadius
            and math.abs(origin.y - pos.y) <= MoveRadius
        --return origin - pos < obbMins and origin - pos < obbMins
    end
    
    function GhastClass:move()
        if self._isStuck or self._moveForward == nil then return end
        local phys = self.propBase:getPhysicsObject()
        phys:wake()
        
        if InterpolationMove then
            self._currentPos = self._currentPos + self._moveForward * GhastVelocity
            local dif = (self._currentPos - self.propBase:getPos()) / InterpolationMoveRatio
            phys:setPos(phys:getPos() + dif)
        else
            self._currentPos = phys:getPos() + self._moveForward * GhastVelocity
            phys:setPos(self._currentPos)
        end
    end
    
    
    
    --########################## Bullet ##########################################################
    
    
    
    function explodeTo(pos)
        while #ExplodeModels > 0 do
            local succeed = pcall(function()
                local p = prop.create(pos, Angle(), ExplodeModels[1])
                p:setNoDraw(true)
                p:breakEnt()
            end)
            
            if succeed then return end
            table.remove(ExplodeModels, 1)
        end
    end
    
    function BulletClass:initialize(pos, targetPos, propBase)
        table.insert(_ghastBulletList, self)
        self.propBase = propBase or nil
        self.targetPos = targetPos or nil
        self.damage = Damage or nil
        self.isExploded = false
        self.isDisposed = false
        self.propDamageMode = PropDamageMode
        self.lastLifeTime = timer.systime() + BulletLifeTime
        self.forward = (targetPos-pos):getNormalized()
        self.head = hologram.create(pos, self.forward and self.forward:getAngle() or Angle(), "models/XQM/Rails/gumball_1.mdl", Vector(1)*0.5)
        self.head:setMaterial("models/props_lab/cornerunit_cloud")
        
        self._obbMins = Vector(-BulletObbSize)
        self._obbMaxs = Vector(BulletObbSize)
    end
    
    function BulletClass:hide()
        self.head:setColor(Color(0,0,0,0))
    end
    
    function BulletClass:destroy()
        if self.isDisposed then throw("Bullet is already disposed") end
        self.head:remove()
        self.isDisposed = true
        table.removeByValue(_ghastBulletList, self)
    end
    
    function BulletClass:explode()
        if self.propDamageMode then
            explodeTo(self.head:getPos())
            self:destroy()
            return
        else
            local plys = find.inSphere(self.head:getPos(), 100, function(ent)
                return ent:isPlayer()
            end)
            for i, ply in ipairs(plys) do
                pcall(function()
                    ply:applyDamage(self.damage, chip(), chip())
                end)
            end
            self.head:emitSound('Plastic_Barrel.BulletImpact', 100, 100, 1)
            self:hide()
            timer.simple(2, function()
                self:destroy()
            end)
        end
        self.isExploded = true
    end
    
    function BulletClass:think()
        if self.lastLifeTime < timer.systime() then
            self:destroy()
            return
        end
        local pos = self.head:getPos()
        local nextPos = pos + self.forward * BulletVelocity * getFrameTime()
        
        local tr = trace.hull(pos, nextPos, self._obbMins, self._obbMaxs, {self.propBase}, MASK.ALL, nil, false)
        if isValid(tr.Entity) or tr.HitWorld then
            self:explode()
            return
        end
        
        self.head:setPos(nextPos)
        --self.head:setAngles(self.forward:getAngle())
    end
    
    -----------------------------------------------------------------------------
    
    hook.add("think", "main", function()
        for k, ghast in pairs(_ghastActiveList) do
            ghast:think()
        end
        
        for i , bullet in ipairs(_ghastBulletList) do
            bullet:think()
        end
    end)
    
    hook.add("EntityTakeDamage", "dmg", function(target, attacker, inflictor, amount, type, position, force)
        for k, ghast in pairs(_ghastActiveList) do
            if ghast.propBase == target then
                ghast:entityTakeDamage(amount)
            end
        end
    end)
    
    timer.create("0.5sec", 0.5, 0, function()
        for k, ghast in pairs(_ghastActiveList) do
            ghast:think05sec()
        end
    end)
    
    timer.create("3sec", 3, 0, function()
        for k, ghast in pairs(_ghastActiveList) do
            ghast:think3sec()
        end
    end)
    
    hook.add("ClientInitialized", "cl_init", function(ply)
        local tab = {}
        for k, ghast in pairs(_ghastActiveList) do
            tab[k] = ghast.propBase
        end
        net.start("ActiveGhasts")
        net.writeTable(tab)
        net.send(ply)
    end)
    
    --------------------------------- CUSTOM CODE -------------------------------------------
    
    if Respawn then
        local ghast1 = nil
        timer.create("", 0.5, 0, function()
            if #table.getKeys(_ghastActiveList) < GhastSpawnCounts then
                GhastClass:new(E:getPos() + Vector(math.random(-200, 200), math.random(-200, 200), 100))
            end
        end)
    else
        local ent = GhastClass:new(E:localToWorld(Vector(0,0,100)))
        timer.create("test123", 0.5, 0, function()
            if ent.isDisposed then
                timer.remove("test123")
                timer.simple(1.5, function()
                    chip():remove()
                end)
            end
        end)
    end
    
    return
end





--============================ CLIENT ======================================================



local _fireballMaterial = "effects/exit1"

---------------------------------------------------------------

local GhastClientClass = class("GhastClientClass")
local SoundManager = class("SoundManager")
    
function GhastClientClass:initialize(id, propBase)
    self.ID = id
    self.propBase = propBase
    self.isDisposed = false
    self._health = Health
    self._isAlive = true

    self:buildSounds()
end

function GhastClientClass:buildSounds()
    self.soundManagerData = getSoundManagerData()
end

function GhastClientClass:think()
end

function GhastClientClass:destruct()
    if self.isDisposed then throw("Ghast is already disposed") end
    self.isDisposed = true
    self.soundManagerData.IsAvailable = true
    _ghastActiveList[self.ID] = nil
end

function GhastClientClass:playSoundMoan()
    if self.isDisposed then return end
    self.soundManagerData.Managers.Moans:playRandom(self.propBase:getPos())
end

function GhastClientClass:attackTarget(target)
    if not isValid(self.propBase) then return end
    local pos = self.propBase:getPos()
    self.soundManagerData.Managers.Other:play("charge", pos)
    timer.simple(1, function()
        self.soundManagerData.Managers.Other:play("fire", pos)
    end)
end

function GhastClientClass:entityTakeDamage(amount, newHealth)
    if not self._isAlive then return end
    --print(newHealth)
    if newHealth > 0 then
        if newHealth < self._health then
            if not self.soundManagerData.Managers.Screams.IsPlaying then
                local pos = self.propBase:getPos()
                self.soundManagerData.Managers.Screams:playRandom(pos)
            end
        end
    else
        self._isAlive = false
        local pos = self.propBase:getPos()
        self.soundManagerData.Managers.Other:play("death", pos)
    end
    self._health = newHealth
end

-------------------- SoundManager -------------------------------------------

local SoundManagers = {}

function getSoundManagerData()
    for i, v in ipairs(SoundManagers) do
        if v.IsAvailable then
            v.IsAvailable = false
            return v
        end
    end
    
    local moans = SoundManager:new("https://raw.githubusercontent.com/Indecastle/Garrys-mod/refs/heads/master/starfall/Resources/ghast/moan_all.mp3", {
        [1] = {Start = 0.0, End = 0.65 },
        [2] = {Start = 0.7, End = 1.45},
        [3] = {Start = 1.45, End = 2.3 },
        [4] = {Start = 2.3, End = 3.1 },
        [5] = {Start = 3.1, End = 4.7 },
        [6] = {Start = 4.7, End = 6.75 },
        [7] = {Start = 6.75, End = 7.7 },
    }, 3000)
    
    local screams = SoundManager:new("https://raw.githubusercontent.com/Indecastle/Garrys-mod/refs/heads/master/starfall/Resources/ghast/scream_all.mp3", {
        [1] = {Start = 0.0, End = 1.0 },
        [2] = {Start = 1.0, End = 2.3 },
        [3] = {Start = 2.3, End = 2.9 },
        [4] = {Start = 2.9, End = 4.2 },
        [5] = {Start = 4.2, End = 5.32 },
    }, 3000)
    
    local other = SoundManager:new("https://raw.githubusercontent.com/Indecastle/Garrys-mod/refs/heads/master/starfall/Resources/ghast/charge_fire_death.mp3", {
        charge = {Start = 0.0, End = 1.0 },
        fire   = {Start = 1.0, End = 1.75 },
        death  = {Start = 1.8, End = 4.90, Volume = 3 },
    }, 3000)
    
    local newManagerData = { 
        Managers = { Moans=moans, Screams=screams, Other=other },
        IsAvailable = false
    }
    table.insert(SoundManagers, newManagerData)
    return newManagerData
end


function SoundManager:initialize(url, items, fadeMax)
    /*schema: 
    {
        url: string,
        items: dict[string: { Start: float, End: float, Volume: float? }]
    }*/
    
    self._timerKey = getNewId()
    
    self.Url = url
    self.Items = items
    self.IsPlaying = false
    
    bass.loadURL(url, "3d noblock noplay", function(Sound)
        if not isValid(Sound) then return end
        Sound:setLooping(false)
        Sound:setPitch(1)
        --Sound:setVolume(1)
        Sound:setFade(50, fadeMax)
        self.Sound = Sound
        --print(Sound:getLength())
    end)
    
end

function SoundManager:isLoaded()
    return self.Sound != nil
end

function SoundManager:play(key, pos)
    if !self:isLoaded() then return end
    local data = self.Items[key]
    self.Sound:pause()
    self.Sound:setPos(pos)
    self.Sound:setVolume(data.Volume or 1)
    timer.remove(self._timerKey)
    timer.create(self._timerKey, data.End - data.Start, 1, function()
        self.Sound:pause()
        self.IsPlaying = false
    end)
    self.Sound:setTime(data.Start)
    self.Sound:play()
    
    self.IsPlaying = true
end

function SoundManager:playRandom(pos)
    if !self:isLoaded() then return end
    local v, k = table.random(self.Items)
    self:play(k, pos)
end

---------------------------------------------------------------


net.receive("ActiveGhasts", function(len)
    local tab = net.readTable()
    for id, propBase in pairs(tab) do
        if isValid(propBase) then
            _ghastActiveList[id] = GhastClientClass:new(id, propBase)
        end
    end
end)

net.receive("AddGhast", function(len)
    local id = net.readString()
    local propBase = net.readEntity(function(ent)
        _ghastActiveList[id] = GhastClientClass:new(id, ent)
    end)
end)

net.receive("RemoveGhast", function(len)
    local id = net.readString()
    if not _ghastActiveList[id] then return end
    _ghastActiveList[id]:destruct()
end)

hook.add("think", "GhastClient", function()
    for id, ghast in pairs(_ghastActiveList) do
        ghast:think()
    end
end)


--############ Custom logic ###################



timer.create("ghastSounds", 6, 0, function()
    local closestGhast, dist
    
    for id, ghast in pairs(_ghastActiveList) do
        if not isValid(ghast.propBase) then continue end
        local newDist = ghast.propBase:getPos():getDistance(player():getPos())
        if not ghast._isAlive then
            continue
        end
        if closestGhast == nil then
            closestGhast = ghast
            dist = newDist
            continue
        end
        if newDist < dist then
            closestGhast = ghast
            dist = newDist
        end
    end
    
    if closestGhast then
        closestGhast:playSoundMoan()
    end
end)

net.receive("AttackTarget", function(len)
    local id = net.readString()
    local propBase = net.readEntity(function(ent)
        if not _ghastActiveList[id] then return end
        _ghastActiveList[id]:attackTarget(ent)
    end)
end)

net.receive("EntityTakeDamage", function(len)
    local id = net.readString()
    local amount = net.readFloat()
    local newHealth = net.readFloat()
    if not _ghastActiveList[id] then return end
    _ghastActiveList[id]:entityTakeDamage(amount, newHealth)
end)

